void *test(void *arg)
{
    thread_vars_t *vars;
    FILE *fp; 
	int index;
	char *current_word;
	node *space;
	list *my_list;

    vars = (thread_vars_t*)arg;
	
	my_list = (list*)malloc(sizeof(list));
	if (!my_list) {
		exit(-2);
	}
	listInit(my_list);

	do
	{
		sem_wait(&sem_index);
			index = (isFileAvailable(vars->num_files) == 1) ? global_index : -1;
		sem_post(&sem_index);
		
		if(index == -1){
			/*printf("BAD INDEX: %i\n", index);*/ 
			pthread_exit(NULL);
		}

		if (!(fp = fopen(vars->files[index + ARGV_DESP],"r"))){ 
			printf("BAD FOPEN: %i\n", fp);
			pthread_exit(NULL);
		}
		
		current_word = (char*)malloc(WORD_SIZE*sizeof(char));
		if (!current_word) {
			printf("BAD CURRENT WORD MALLOC: %i\n", current_word);
			pthread_exit(NULL);
		}
		
		while(fscanf(fp,"%s",current_word) != EOF) { 
			space = (node*)malloc(sizeof(node)); 
			if(!space) {
				printf("BAD SPACE MALLOC: %i\n", space);
				pthread_exit(NULL);
			}
			
			nodeInit(space, current_word, 0);

			if (listInsert(my_list, space) < 0) {
				free(space);
				free(current_word);
			}
			
			current_word = (char*)malloc(WORD_SIZE*sizeof(char)); 			
			if(!current_word) {
				printf("BAD CURRENT WORD MALLOC 2: %i\n", current_word);
				pthread_exit(NULL);
			}
		}
		
		listSort(my_list);
		sem_wait(&sem_merge);
			/*printf("----------\n");
			listPrint(my_list);
			printf("----------\n");*/
			/*listMerge(vars->main_list, my_list);*/
		sem_post(&sem_merge);

		free(current_word);
		free(my_list);
	} while (index >= 0);

	pthread_exit(NULL);
}

int isFileAvailable(int n){
	if(global_index < n - 1){
		global_index++;
		return 1;
	}else{
		return -1;
	}
}


void listMerge(list *list_a, list *list_b){
    /*Definicion de variables*/
    int size_list_a, size_list_b;
    node *node_a, *node_b;
    list *new_list;

    /*Inicializacion de variables*/
    size_list_a = list_a->size;
    size_list_b = list_b->size;

    /*Se ubica cada nodo al inicio de la lista*/
    node_a = list_a->head;
    node_b = list_b->head;

	/*Si la lista_a esta vacia, se copia la lista_b en lista_a*/
	if(size_list_a == 0){
		list_a->head = list_b->head;
		list_a->tail = list_b->tail;
		list_a->size = list_b->size;
		return;
	}/*Si la lista_b esta vacia, no se realiza mezcla alguna*/
	else if(size_list_b == 0){
		return;
	}
	else{
		while(size_list_a > 0 && size_list_b > 0){
			node *contains = listSearch(list_a, node_b); 
			if (contains != NULL) {
				contains->frequency += node_b->frequency;
				size_list_b--;
				node_b = node_b->next;
			}
			else {
				if (nodeCompare(node_a, node_b) >= 0){
					size_list_a--;
					node_a = node_a->next;
				}
				else{
					if(list_a->head == node_a){
						listInsertBetween(list_a, NULL, node_b);
					}
					else{
						listInsertBetween(list_a, node_a, node_b);
					}
					size_list_b--;
					node_b = node_b->next;
				}
			}
		}
		
		/*Completa la copia del sobrante de la lista b*/
		if (size_list_b > 0){
			while(size_list_b > 0){
				listInsertBetween(list_a, list_a->tail, node_b);
				list_a->tail = node_b;
				size_list_b--;
				node_b = node_b->next;
			}
		}
	}
}